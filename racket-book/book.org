:PROPERTIES:
:header-args:racket: :lang racket
:header-args: :eval no :exports code
:END:

#+TITLE: Racket for the Masses

* Introduction

* Learn any Scheme in 20 minutes or less
** How to use functions
Calling a function in Racket is slightly different from other languages. The parenthesis surrounds the function name and the argument list do not need commas.

Javascript:
#+begin_src js
stringAppend("a", "b", "c");
#+end_src

Racket:
#+begin_src racket
(string-append "a" "b" "c")
#+end_src

Play close attention to that because everything else is based on that format. In general, to call a function the format is:

#+begin_src racket
(function-name arg1 arg2 arg3 ...)
#+end_src
** Things that are not functions look like functions
Racket, and any other Scheme language, are extremely consistent. There is no special syntaxes or reserved words. It might be a little weird in the beginning, but after a short while this homogenity starts to feel really comfortable and you will be thinking why other languages can not be just more consistent.
*** Math looks like functions
:PROPERTIES:
:header-args: :eval try :exports both
:END:
Math has no special representation nor it changes the way the code is normally evaluated.

So, this in most languages:

#+begin_src ruby
1 + 2 + 3 * 4 * 5
#+end_src

#+RESULTS:
: 63

Is written in Racket like this:

#+begin_src racket
(+ 1 2 (* 3 4 5))
#+end_src

#+RESULTS:
: 63

Probably you've noticed that mathematical functions accepts multiple arguments, not just two as a traditional mathematical operator. So, this is a sum:

#+begin_src racket
(+ 1 2 3 4 5 6)
#+end_src

#+RESULTS:
: 21

That also is true for boolean and comparison functions.

Think of this one as "arguments are in crescent order":
#+begin_src racket
(< 0 2 8 10)
#+end_src

#+RESULTS:
: #t

And this one is "all the conditions are true":
#+begin_src racket
(and (< 1 2) (<= 3 3 4 5) (= 1 1 1))
#+end_src
*** Control structures look like functions
Other languages have "commands", reserved words, and special syntaxes for *control structures*. There is no such things in Racket. For example, ~if~ is usually reserved in other languages and have a special structure:

In Ruby, it is:

#+begin_src ruby :results silent :var a=1 b=1
if a == b
  1
else
  2
end
#+end_src

Or in Javascript:

#+begin_src js :results silent :var a=1 b=1
a === b ? 1 : 2;
#+end_src

The equivalent in Racket is:

#+begin_src racket :lang racket :results silent :var a=1 b=1
(if (= a b) 1 2)
#+end_src

Note that it looks exactly like a function call.
*** Variable assigment looks like functions
A variable assignment (called *binding* in Racket) usually has a special structure in other languages. In Racket they look like functions, as everything else.

Variable assignment in Ruby:

#+begin_src ruby :results silent
a = 1
#+end_src

In Racket:

#+begin_src racket :lang racket
(define a 1)
#+end_src
*** Function definitions also look like function calls
Any other language have well defined syntaxes and reserved keywords for defining functions, methods, classes and so on.

For example, a function in Python is defined like this:

#+begin_src python :results pp :session
def add1(a):
    return a + 1

add1(10)
#+end_src

#+RESULTS:
: 11

In Racket, defining a function looks like we are just /calling/ the function ~define~:

#+begin_src racket :lang racket
(define (add1 a) (+ a 1))
(add1 10)
#+end_src

#+RESULTS:
: 11

*** Anonymous functions look like functions
:PROPERTIES:
:header-args: :exports both
:END:

Anonymous functions or code block in other languages also have special syntaxes. For example, a code block in Ruby looks like this:

#+begin_src ruby
add1 = -> a { a + 1 }
add1[10]
#+end_src

#+RESULTS:
: 11

In Racket they still look like functions:

#+begin_src racket :lang racket :results silent
(define add1 (lambda (a) (+ a 1)))
(add1 10)
#+end_src

Or using the character "λ" instead of the word "lambda".

#+begin_src racket :lang racket
(define add1 (λ (a) (+ a 1)))
(add1 10)
#+end_src

#+RESULTS:
: 11

However, for simple functions like that, it is common to just use currying.

#+begin_src racket :lang racket
(define add1 (curry + 1))
(add1 10)
#+end_src

#+RESULTS:
: 11

*** We call them "forms"
Given that the syntax for functions and everything else looks exactly the same, we need a name for them. In Racket they are called /forms/.

** Function are just variables
*** They are cheap
**** It is common to use them to reduce nesting
*** They are passed as arguments or attributed to variables
** Polymorphism was introduced later
:PROPERTIES:
:header-args:racket: :exports code :eval no
:END:
Racket is a Scheme-like language which is quite old. So old that is predates polymorphism or method/function overloading. That means we still have a lot of functions that are prefixed by the type of data they act upon.

For example, to get the second value of:
- A list: we can write src_racket{(list-ref my-list 1)}
- A vector, we should write src_racket{(vector-ref my-vector 1)}.
- A hash, it would be src_racket{(dict-ref my-dict 1)}.

However, now Racket supports polymorphism and modern code can use functions like:
- src_racket{(sequence-ref anything 1)} if we use the standard library.
- src_racket{(ref anything 1)} if we use the excellent [[https://docs.racket-lang.org/collections/index.html][Generic Collections]] library.
** Peculiarities
*** There is a small set of symbols that are reserved: ~() [] {} # |~, everything else can be overwritten.
*** The language uses dashes for separate words in identifiers, like ~string-append~ or ~vector-ref~.
*** There is no operator for "not equal" like ~!=~. Conditionals have an inverse counterpart (like ~when~ and ~unless~), we use ~(not x)~, ~(negate f)~, or just the structure the code to avoid the negation.
* Programming Language Oriented
** Create the language to solve your problem
** All languages are interoperable
*** Each file is a different language
**** The truth is, a file is a module
** Do not be afraid of Macros
*** They are a basic component of Racket
*** They are cheap, done in compiling time
*** They can be difficult to debug, so keep them short
**** If you using them locally, do not refrain yourself
**** If you are building a library, spend time making them bullet-proof and on error messages.
